[
  {
    "outputSchema": {
      "type": "object",
      "properties": {
        "action_type": {
          "description": "The callback method that was handled",
          "type": "string"
        },
        "success": {
          "description": "Whether the action was executed successfully",
          "type": "boolean"
        },
        "action_taken": {
          "description": "Description of what was done (e.g. \"passed_priority\")",
          "type": "string"
        },
        "game_over": {
          "description": "Whether the game has ended",
          "type": "boolean"
        },
        "recent_chat": {
          "description": "Chat messages received since last check",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "error": {
          "description": "Error message",
          "type": "string"
        },
        "player_dead": {
          "description": "Whether you died",
          "type": "boolean"
        }
      }
    },
    "examples": [
      {
        "label": "Success",
        "value": "{\n  \"success\": true,\n  \"action_type\": \"GAME_SELECT\",\n  \"action_taken\": \"passed_priority\"\n}"
      },
      {
        "label": "No pending action",
        "value": "{\n  \"success\": false,\n  \"error\": \"No pending action\"\n}"
      }
    ],
    "inputSchema": {
      "additionalProperties": false,
      "type": "object",
      "properties": {}
    },
    "name": "default_action",
    "description": "Execute default action (pass priority or first available choice)"
  },
  {
    "outputSchema": {
      "type": "object",
      "properties": {
        "cursor": {
          "description": "Cursor to pass to the next get_game_log call",
          "type": "integer"
        },
        "cursor_reset": {
          "description": "Whether requested cursor was too old and had to be reset to oldest retained log offset",
          "type": "boolean"
        },
        "since_player": {
          "description": "The player whose turn the log starts from",
          "type": "string"
        },
        "log": {
          "description": "Game log text (may be truncated if max_chars was set)",
          "type": "string"
        },
        "since_turn": {
          "description": "The per-player turn number the log starts from",
          "type": "integer"
        },
        "truncated": {
          "description": "Whether older content was omitted",
          "type": "boolean"
        },
        "total_length": {
          "description": "Total length of the full game log in characters",
          "type": "integer"
        }
      }
    },
    "examples": [
      {
        "label": "Truncated log",
        "value": "{\n  \"log\": \"Alice turn 3 (20 - 15)\\nAlice casts Lightning Bolt...\",\n  \"total_length\": 5234,\n  \"truncated\": true,\n  \"cursor\": 5234\n}"
      },
      {
        "label": "Cursor delta",
        "value": "{\n  \"log\": \"Bob casts Swords to Plowshares targeting Goblin Guide.\",\n  \"total_length\": 5301,\n  \"truncated\": false,\n  \"cursor\": 5301\n}"
      },
      {
        "label": "Since turn recap",
        "value": "{\n  \"log\": \"Bob turn 2 (20 - 18)\\nBob casts Sol Ring\\nAlice turn 3 (20 - 18)\\nAlice plays Forest\",\n  \"total_length\": 5400,\n  \"truncated\": false,\n  \"cursor\": 5400,\n  \"since_turn\": 2,\n  \"since_player\": \"Bob\"\n}"
      }
    ],
    "inputSchema": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "cursor": {
          "description": "Cursor offset from previous get_game_log call. Returns new log text since this offset. Mutually exclusive with since_turn.",
          "type": "integer"
        },
        "max_chars": {
          "description": "Max characters to return (0 or omit for all)",
          "type": "integer"
        },
        "since_player": {
          "description": "Player name for since_turn filter. Defaults to you (the calling player). Only used with since_turn.",
          "type": "string"
        },
        "since_turn": {
          "description": "Return log entries starting from this player turn number. Turn markers use per-player numbering (e.g. 'Alice turn 3'). Mutually exclusive with cursor.",
          "type": "integer"
        }
      }
    },
    "name": "get_game_log",
    "description": "Get game log text. Three modes: (1) since_turn=N to get events since a player's Nth turn (best for recapping opponents' turns in multiplayer), (2) cursor from a previous call for incremental updates, (3) max_chars for the most recent N characters."
  },
  {
    "outputSchema": {
      "type": "object",
      "properties": {
        "success": {
          "description": "Whether the message was sent",
          "type": "boolean"
        }
      }
    },
    "examples": [
      {
        "label": "Success",
        "value": "{\n  \"success\": true\n}"
      }
    ],
    "inputSchema": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "message": {
          "description": "Message to send",
          "type": "string"
        }
      },
      "required": [
        "message"
      ]
    },
    "name": "send_chat_message",
    "description": "Send a chat message to the game"
  },
  {
    "outputSchema": {
      "type": "object",
      "properties": {
        "combat_phase": {
          "description": "\"declare_attackers\" or \"declare_blockers\"",
          "type": "string"
        },
        "actions_passed": {
          "description": "Number of priority passes performed",
          "type": "integer"
        },
        "has_playable_cards": {
          "description": "Whether you have playable cards in hand",
          "type": "boolean"
        },
        "action_type": {
          "description": "XMage callback method name",
          "type": "string"
        },
        "stop_reason": {
          "description": "Why the call returned: playable_cards, combat, non_priority_action, game_over, reached_step (target step reached), step_not_reached (turn ended without reaching step)",
          "type": "string"
        },
        "recent_chat": {
          "description": "Chat messages received since last check",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "action_pending": {
          "description": "Whether a decision-requiring action was found",
          "type": "boolean"
        },
        "current_step": {
          "description": "Current game step (only for reached_step/step_not_reached)",
          "type": "string"
        },
        "player_dead": {
          "description": "Whether you died during priority passing",
          "type": "boolean"
        }
      }
    },
    "examples": [
      {
        "label": "Playable cards found",
        "value": "{\n  \"action_pending\": true,\n  \"action_type\": \"GAME_SELECT\",\n  \"actions_passed\": 3,\n  \"has_playable_cards\": true,\n  \"stop_reason\": \"playable_cards\"\n}"
      },
      {
        "label": "Combat phase",
        "value": "{\n  \"action_pending\": true,\n  \"action_type\": \"GAME_SELECT\",\n  \"actions_passed\": 5,\n  \"has_playable_cards\": false,\n  \"combat_phase\": \"declare_attackers\",\n  \"stop_reason\": \"combat\"\n}"
      },
      {
        "label": "Non-priority action (mulligan, targeting)",
        "value": "{\n  \"action_pending\": true,\n  \"action_type\": \"GAME_ASK\",\n  \"actions_passed\": 0,\n  \"stop_reason\": \"non_priority_action\"\n}"
      },
      {
        "label": "Yield until next turn",
        "value": "{\n  \"action_pending\": true,\n  \"action_type\": \"GAME_SELECT\",\n  \"actions_passed\": 8,\n  \"has_playable_cards\": true,\n  \"stop_reason\": \"playable_cards\"\n}"
      },
      {
        "label": "Yield to step (reached)",
        "value": "{\n  \"action_pending\": true,\n  \"action_type\": \"GAME_SELECT\",\n  \"actions_passed\": 12,\n  \"current_step\": \"Declare Attackers\",\n  \"stop_reason\": \"reached_step\"\n}"
      },
      {
        "label": "Yield to step (turn ended)",
        "value": "{\n  \"action_pending\": true,\n  \"action_type\": \"GAME_SELECT\",\n  \"actions_passed\": 6,\n  \"current_step\": \"Upkeep\",\n  \"stop_reason\": \"step_not_reached\"\n}"
      }
    ],
    "inputSchema": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "until": {
          "description": "Skip ahead to a target. Step values yield within the current turn (client-side): upkeep, draw, precombat_main, begin_combat, declare_attackers, declare_blockers, end_combat, postcombat_main. Cross-turn values use server-side yield: end_of_turn (skip rest of turn), my_turn (skip to your next turn), stack_resolved (wait for stack to resolve). Omit to block until next actionable priority.",
          "type": "string",
          "enum": [
            "upkeep",
            "draw",
            "precombat_main",
            "begin_combat",
            "declare_attackers",
            "declare_blockers",
            "end_combat",
            "postcombat_main",
            "end_of_turn",
            "my_turn",
            "stack_resolved"
          ]
        }
      }
    },
    "name": "pass_priority",
    "description": "Pass priority. Blocks until you have a pending action (playable cards, combat, non-priority action like mulligan/targeting). With until: skips ahead to a target step or phase. Step values (current turn, client-side): upkeep, draw, precombat_main, begin_combat, declare_attackers, declare_blockers, end_combat, postcombat_main. Cross-turn values (server-side): end_of_turn, my_turn, stack_resolved. Always stops for combat and non-priority actions. Auto-handles mechanical callbacks (mana payment failures, optional targets with no legal targets). Returns stop_reason indicating why the call returned."
  },
  {
    "outputSchema": {
      "type": "object",
      "properties": {
        "cursor": {
          "description": "Cursor for the latest known game state",
          "type": "integer"
        },
        "phase": {
          "description": "Current phase (e.g. PRECOMBAT_MAIN, COMBAT)",
          "type": "string"
        },
        "priority_player": {
          "description": "Name of the player who currently has priority",
          "type": "string"
        },
        "stack": {
          "description": "Stack objects: name, rules, target_count",
          "type": "array",
          "items": {
            "type": "object"
          }
        },
        "active_player": {
          "description": "Name of the player whose turn it is",
          "type": "string"
        },
        "players": {
          "description": "Player objects: name, life, library_size, hand_size, is_active, is_you, hand (yours only), battlefield, graveyard, exile, mana_pool, counters, commanders",
          "type": "array",
          "items": {
            "type": "object"
          }
        },
        "available": {
          "description": "Whether game state is available",
          "type": "boolean"
        },
        "unchanged": {
          "description": "True when the provided cursor already matches the latest state",
          "type": "boolean"
        },
        "step": {
          "description": "Current step within the phase",
          "type": "string"
        },
        "combat": {
          "description": "Combat groups: attackers, blockers, blocked, defending",
          "type": "array",
          "items": {
            "type": "object"
          }
        },
        "turn": {
          "description": "Current turn number",
          "type": "integer"
        },
        "error": {
          "description": "Error message",
          "type": "string"
        }
      }
    },
    "examples": [
      {
        "label": "Mid-game state",
        "value": "{\n  \"available\": true,\n  \"turn\": 4,\n  \"phase\": \"PRECOMBAT_MAIN\",\n  \"step\": \"PRECOMBAT_MAIN\",\n  \"active_player\": \"Player1\",\n  \"priority_player\": \"Player1\",\n  \"players\": [\n    {\n      \"name\": \"Player1\",\n      \"life\": 18,\n      \"library_size\": 49,\n      \"hand_size\": 5,\n      \"is_active\": true,\n      \"is_you\": true,\n      \"hand\": [\n        {\n          \"name\": \"Lightning Bolt\",\n          \"mana_cost\": \"{R}\",\n          \"mana_value\": 1,\n          \"playable\": true\n        },\n        {\n          \"name\": \"Mountain\",\n          \"mana_value\": 0,\n          \"is_land\": true,\n          \"playable\": true\n        }\n      ],\n      \"battlefield\": [\n        {\n          \"name\": \"Mountain\",\n          \"tapped\": false\n        },\n        {\n          \"name\": \"Goblin Guide\",\n          \"tapped\": false,\n          \"power\": 2,\n          \"toughness\": 2\n        }\n      ],\n      \"mana_pool\": {\n        \"R\": 0\n      }\n    },\n    {\n      \"name\": \"Player2\",\n      \"life\": 20,\n      \"library_size\": 52,\n      \"hand_size\": 7,\n      \"is_active\": false,\n      \"is_you\": false,\n      \"battlefield\": [\n        {\n          \"name\": \"Island\",\n          \"tapped\": false\n        }\n      ]\n    }\n  ],\n  \"stack\": []\n}"
      }
    ],
    "inputSchema": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "cursor": {
          "description": "State cursor from previous get_game_state call. If unchanged, returns a compact payload.",
          "type": "integer"
        }
      }
    },
    "name": "get_game_state",
    "description": "Get full game state: turn, phase, players, stack, combat. Each player has life, mana_pool, hand (yours only), battlefield (name, tapped, P/T, counters, token/copy/face_down flags), graveyard, exile, commanders."
  },
  {
    "outputSchema": {
      "type": "object",
      "properties": {
        "cards": {
          "description": "Array of {name, rules} or {name, error} per card",
          "type": "array",
          "items": {
            "type": "object"
          }
        },
        "success": {
          "description": "Whether the lookup succeeded",
          "type": "boolean"
        },
        "name": {
          "description": "Card name",
          "type": "string"
        },
        "rules": {
          "description": "Oracle text lines",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "error": {
          "description": "Error message",
          "type": "string"
        }
      }
    },
    "examples": [
      {
        "label": "Single card",
        "value": "{\n  \"success\": true,\n  \"name\": \"Lightning Bolt\",\n  \"rules\": [\n    \"Deal 3 damage to any target.\"\n  ]\n}"
      },
      {
        "label": "Batch card_names lookup",
        "value": "{\n  \"success\": true,\n  \"cards\": [\n    {\n      \"name\": \"Lightning Bolt\",\n      \"rules\": [\n        \"Deal 3 damage to any target.\"\n      ]\n    },\n    {\n      \"name\": \"Counterspell\",\n      \"rules\": [\n        \"Counter target spell.\"\n      ]\n    }\n  ]\n}"
      },
      {
        "label": "Batch object_ids lookup",
        "value": "{\n  \"success\": true,\n  \"cards\": [\n    {\n      \"object_id\": \"p3\",\n      \"name\": \"Lightning Bolt\",\n      \"rules\": [\n        \"Deal 3 damage to any target.\"\n      ]\n    },\n    {\n      \"object_id\": \"p99\",\n      \"error\": \"not found\"\n    }\n  ]\n}"
      },
      {
        "label": "Not found",
        "value": "{\n  \"success\": false,\n  \"error\": \"not found\"\n}"
      }
    ],
    "inputSchema": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "object_ids": {
          "description": "Batch in-game object short ID lookup (e.g. [\"p1\",\"p2\"])",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "card_name": {
          "description": "Single card name lookup",
          "type": "string"
        },
        "card_names": {
          "description": "Batch card name lookup",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "object_id": {
          "description": "Short ID of an in-game object (e.g. \"p3\")",
          "type": "string"
        }
      }
    },
    "name": "get_oracle_text",
    "description": "Get oracle text (rules) for cards. Provide exactly one of: card_name (single), card_names (batch array), object_id (in-game object), or object_ids (batch array of in-game objects). Single returns {name, rules}. Batch returns {cards: [{name, rules}, ...]}."
  },
  {
    "outputSchema": {
      "type": "object",
      "properties": {
        "combat_phase": {
          "description": "\"declare_attackers\" or \"declare_blockers\"",
          "type": "string"
        },
        "action_type": {
          "description": "XMage callback method name",
          "type": "string"
        },
        "players": {
          "description": "Life total summary (e.g. \"You(20), Opp(18)\")",
          "type": "string"
        },
        "min_amount": {
          "description": "Minimum allowed value",
          "type": "integer"
        },
        "response_type": {
          "description": "How to respond: \"select\", \"boolean\", \"index\", \"amount\", \"pile\", or \"multi_amount\"",
          "type": "string"
        },
        "stop_reason": {
          "description": "Why pass_priority returned (only when until is set)",
          "type": "string"
        },
        "untapped_lands": {
          "description": "Number of untapped lands",
          "type": "integer"
        },
        "message": {
          "description": "Human-readable prompt from XMage",
          "type": "string"
        },
        "mana_pool": {
          "description": "Current mana pool {R, G, U, W, B, C}",
          "type": "object"
        },
        "action_pending": {
          "description": "Whether an action is pending (false if nothing to do)",
          "type": "boolean"
        },
        "actions_passed": {
          "description": "Number of priority passes performed before the decision",
          "type": "integer"
        },
        "context": {
          "description": "Turn/phase context (e.g. \"T3 PRECOMBAT_MAIN (Player1) YOUR_MAIN\")",
          "type": "string"
        },
        "max_amount": {
          "description": "Maximum allowed value",
          "type": "integer"
        },
        "recent_chat": {
          "description": "Chat messages received since last check",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "choices": {
          "description": "Structured choices with index, name, and type-specific fields (action/mana_cost/power/toughness for cards; choice_type for combat/mana; target_type/controller/tapped for targets)",
          "type": "array",
          "items": {
            "type": "object"
          }
        },
        "your_hand": {
          "description": "Hand cards with name, mana_cost, mana_value",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "examples": [
      {
        "label": "Select (play cards)",
        "value": "{\n  \"action_pending\": true,\n  \"action_type\": \"GAME_SELECT\",\n  \"message\": \"Select card to play or pass priority\",\n  \"response_type\": \"select\",\n  \"context\": \"T3 PRECOMBAT_MAIN (Player1) YOUR_MAIN\",\n  \"players\": \"You(20), Opp(18)\",\n  \"choices\": [\n    {\n      \"index\": 0,\n      \"name\": \"Lightning Bolt\",\n      \"action\": \"cast\",\n      \"mana_cost\": \"{R}\",\n      \"mana_value\": 1\n    },\n    {\n      \"index\": 1,\n      \"name\": \"Mountain\",\n      \"action\": \"land\"\n    }\n  ],\n  \"untapped_lands\": 2\n}"
      },
      {
        "label": "Boolean (mulligan)",
        "value": "{\n  \"action_pending\": true,\n  \"action_type\": \"GAME_ASK\",\n  \"message\": \"Mulligan hand?\",\n  \"response_type\": \"boolean\",\n  \"context\": \"T0 PREGAME\",\n  \"players\": \"You(20), Opp(20)\",\n  \"your_hand\": [\n    {\n      \"name\": \"Mountain\",\n      \"mana_value\": 0,\n      \"is_land\": true\n    },\n    {\n      \"name\": \"Lightning Bolt\",\n      \"mana_cost\": \"{R}\",\n      \"mana_value\": 1\n    }\n  ],\n  \"hand_size\": 7,\n  \"land_count\": 3\n}"
      }
    ],
    "inputSchema": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "until": {
          "description": "Skip ahead to a target, then return choices. Same values as pass_priority's until parameter. Omit to return immediately.",
          "type": "string",
          "enum": [
            "upkeep",
            "draw",
            "precombat_main",
            "begin_combat",
            "declare_attackers",
            "declare_blockers",
            "end_combat",
            "postcombat_main",
            "end_of_turn",
            "my_turn",
            "stack_resolved"
          ]
        }
      }
    },
    "name": "get_action_choices",
    "description": "Get available choices for the current pending action. Call before choose_action. With until: blocks like pass_priority until a decision is needed, then returns choices in one call. Without until: returns immediately (action_pending=false if nothing to do). Includes context (phase/turn), players (life totals), and land_drops_used (during your main phase). response_type: select (cards to play, attackers, blockers), boolean (yes/no), index (target/ability), amount, pile, or multi_amount. During combat: combat_phase indicates declare_attackers or declare_blockers."
  },
  {
    "outputSchema": {
      "type": "object",
      "properties": {
        "retryable": {
          "description": "Whether the action can be retried with different parameters",
          "type": "boolean"
        },
        "declared": {
          "description": "IDs of successfully declared attackers/blockers (batch combat)",
          "type": "array"
        },
        "success": {
          "description": "Whether the action was accepted",
          "type": "boolean"
        },
        "action_taken": {
          "description": "Description of what was done (e.g. \"selected_0\", \"yes\", \"passed_priority\", \"batch_attack\")",
          "type": "string"
        },
        "warning": {
          "description": "Warning (e.g. possible game loop detected)",
          "type": "string"
        },
        "mana_plan_set": {
          "description": "Whether a mana plan was stored for upcoming payment callbacks",
          "type": "boolean"
        },
        "error_code": {
          "description": "Machine-readable error code: no_pending_action, missing_param, index_out_of_range, invalid_choice, internal_error, unknown_action_type",
          "type": "string"
        },
        "failed": {
          "description": "Entries that failed during batch combat: {id, reason}",
          "type": "array"
        },
        "interrupted": {
          "description": "Whether batch combat was interrupted by a trigger",
          "type": "boolean"
        },
        "error": {
          "description": "Error message",
          "type": "string"
        },
        "mana_plan_size": {
          "description": "Number of entries in the stored mana plan",
          "type": "integer"
        }
      }
    },
    "examples": [
      {
        "label": "ID-based selection",
        "value": "{\n  \"success\": true,\n  \"action_taken\": \"selected_2\"\n}"
      },
      {
        "label": "Boolean answer",
        "value": "{\n  \"success\": true,\n  \"action_taken\": \"no\"\n}"
      },
      {
        "label": "Cast with mana plan",
        "value": "{\n  \"success\": true,\n  \"action_taken\": \"selected_2\",\n  \"mana_plan_set\": true,\n  \"mana_plan_size\": 3\n}"
      },
      {
        "label": "Batch attack",
        "value": "{\n  \"success\": true,\n  \"action_taken\": \"batch_attack\",\n  \"declared\": [\n    \"p1\",\n    \"p2\",\n    \"p3\"\n  ]\n}"
      },
      {
        "label": "Batch block",
        "value": "{\n  \"success\": true,\n  \"action_taken\": \"batch_block\",\n  \"declared\": [\n    {\n      \"id\": \"p5\",\n      \"blocks\": \"p1\"\n    },\n    {\n      \"id\": \"p6\",\n      \"blocks\": \"p2\"\n    }\n  ]\n}"
      },
      {
        "label": "Error",
        "value": "{\n  \"success\": false,\n  \"error\": \"Index 5 out of range (call get_action_choices first)\",\n  \"error_code\": \"index_out_of_range\",\n  \"retryable\": true\n}"
      }
    ],
    "inputSchema": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "amount": {
          "description": "Amount value (for get_amount actions)",
          "type": "integer"
        },
        "answer": {
          "description": "Yes/No response. For GAME_ASK: true means YES to the question, false means NO. For mulligan: true = YES MULLIGAN (discard hand, draw new cards), false = NO KEEP (keep this hand). For GAME_SELECT: false = pass priority (done playing cards this phase), true = confirm combat (done declaring attackers/blockers). Also false to cancel target/mana selection.",
          "type": "boolean"
        },
        "amounts": {
          "description": "Multiple amount values (for multi_amount actions)",
          "type": "array",
          "items": {
            "type": "integer"
          }
        },
        "auto_tap": {
          "description": "Set true to use the automatic mana tapper. WARNING: The autotapper is not smart — it taps the first available source with no color awareness and uses a naive heuristic for multi-ability lands. Prefer mana_plan for strategic tapping. Only use auto_tap to save tokens when tapping order doesn't matter.",
          "type": "boolean"
        },
        "pile": {
          "description": "Pile number: 1 or 2 (for pile choices)",
          "type": "integer"
        },
        "index": {
          "description": "Choice index from get_action_choices",
          "type": "integer"
        },
        "mana_plan": {
          "description": "JSON array of mana sources to tap when casting a spell. Each entry: {\"tap\": \"p3\"} to tap a permanent by short ID, or {\"pool\": \"RED\"} to spend mana from pool (valid types: WHITE, BLUE, BLACK, RED, GREEN, COLORLESS). Consumed in order as mana payment callbacks arrive. Example: [{\"tap\": \"p1\"}, {\"tap\": \"p2\"}]. The plan must be COMPLETE — if any entry fails (wrong ID, unavailable permanent) or the plan runs out before all mana is paid, the spell is cancelled. Avoid multi-ability permanents (filter lands, dual lands) — they cancel the spell. For X spells, include entries for both the X pips and the regular cost. Mutually exclusive with auto_tap.",
          "type": "string"
        },
        "attackers": {
          "description": "Declare multiple attackers at once. Array of short IDs (e.g. [\"p1\",\"p2\"]). Use [\"all\"] to declare all possible attackers. Automatically confirms after declaring.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "blockers": {
          "description": "Declare multiple blockers at once. JSON array of assignments: [{\"id\":\"p5\",\"blocks\":\"p1\"},{\"id\":\"p6\",\"blocks\":\"p2\"}]. Each entry specifies which attacker the blocker should block (use IDs from incoming_attackers). Automatically confirms after declaring.",
          "type": "string"
        },
        "id": {
          "description": "Short ID of the object to select (e.g. \"p3\"). Alternative to index. Mutually exclusive with index.",
          "type": "string"
        },
        "text": {
          "description": "Text value for GAME_CHOOSE_CHOICE (use instead of index to pick any option by name, e.g. a creature type not in the filtered list)",
          "type": "string"
        }
      }
    },
    "name": "choose_action",
    "description": "Respond to pending action. Use id or index to pick a choice (card, attacker, blocker, target, ability, mana source). Use answer for yes/no, pass priority, or confirm combat (true=confirm attackers/blockers). Use attackers/blockers for batch combat. Call get_action_choices first."
  },
  {
    "outputSchema": {
      "type": "object",
      "properties": {
        "cards": {
          "description": "Main deck cards, one per line (e.g. \"4x Lightning Bolt\")",
          "type": "string"
        },
        "sideboard": {
          "description": "Sideboard cards, same format",
          "type": "string"
        },
        "error": {
          "description": "Error message",
          "type": "string"
        }
      }
    },
    "examples": [
      {
        "label": "Decklist loaded",
        "value": "{\n  \"cards\": \"4x Lightning Bolt\\n4x Goblin Guide\\n20x Mountain\",\n  \"sideboard\": \"2x Smash to Smithereens\\n3x Eidolon of the Great Revel\"\n}"
      }
    ],
    "inputSchema": {
      "additionalProperties": false,
      "type": "object",
      "properties": {}
    },
    "name": "get_my_decklist",
    "description": "Get your original decklist (card names and quantities)."
  }
]
