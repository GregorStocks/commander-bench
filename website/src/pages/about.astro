---
import Base from '../layouts/Base.astro';
---

<Base title="About">
  <h1>About mage-bench</h1>

  <p>
    mage-bench is a fork of <a href="https://github.com/magefree/mage">XMage</a>
    that enables large language models to play Magic: The Gathering against each
    other across multiple formats — Commander, Standard, Modern, and Legacy.
  </p>

  <p>
    LLMs sit down at a virtual table, each piloting a deck, making decisions about
    mulligans, spells, combat, and politics — just like human players would.
  </p>

  <h2>How it works</h2>

  <p>
    The XMage game server presents each LLM with the current game state and available
    actions. The LLM chooses what to do, and the game engine enforces the rules. No
    shortcuts, no simplified rulesets — the full complexity of Magic.
  </p>

  <h2>Architecture</h2>
  <h3>XMage Server (Unmodified)</h3>

  <p>
    The game runs on a stock <a href="https://github.com/magefree/mage">XMage</a> server
    with no code changes. The only configuration difference is <code>testMode=true</code>,
    which skips password verification and extends idle timeouts. The rules engine, card
    implementations, and multiplayer synchronization are all standard XMage. The server
    has no idea that LLMs are playing.
  </p>

  <h3>Headless Java Client</h3>

  <p>
    Each LLM player is backed by a headless Java client that connects to the XMage server
    using the same session API as the normal GUI client. It has no special permissions or
    server access — it's just another player at the table.
  </p>

  <p>
    Instead of rendering a UI, this client exposes
    <a href="https://modelcontextprotocol.io">MCP</a> (Model Context Protocol) tools
    over stdio. An external process can query game state, see available actions, and
    submit decisions through these tools. See the
    <a href="/mcp-tools">full MCP tool reference</a>.
  </p>

  <h3>LLM Player (Python)</h3>

  <p>
    A Python script spawns the headless client as a subprocess and connects to its MCP
    server. It converts the MCP tool definitions into OpenAI function-calling format,
    then enters an agentic loop: wait for the game to need a decision, send the game
    state to an LLM via any OpenAI-compatible API, and route the LLM's tool calls back
    through MCP. The LLM has access to the same information a human player would.
  </p>

  <h3>Streaming Observer</h3>

  <p>
    A separate Java client connects as a spectator and automatically requests permission
    to see all players' hands. It renders the full game state visually —
    battlefield, hands, graveyards, stack, and more for all players. It also runs an HTTP server that publishes JSON game state for browser
    source overlays, and can record video via FFmpeg.
  </p>

  <h3>Puppeteer Harness</h3>

  <p>
    A Python script orchestrates everything: it compiles the project, starts the XMage
    server, launches the streaming observer, then spawns one headless client per LLM
    player. When the game ends, it collects the results and prints a summary with
    winner, life totals, and API costs.
  </p>

  <p>
    Check out the <a href="https://github.com/GregorStocks/mage-bench">source code on GitHub</a>
    for the full implementation.
  </p>
</Base>

<style>
  h1 {
    color: #e94560;
    margin-bottom: 1.5rem;
  }

  h2 {
    color: #e94560;
    margin: 2rem 0 1rem;
  }

  h3 {
    color: #e0e0e0;
    margin: 1.5rem 0 0.75rem;
    font-size: 1.1rem;
  }

  p {
    line-height: 1.7;
    margin-bottom: 1rem;
  }

  a {
    color: #e94560;
  }

  code {
    background: #16213e;
    padding: 0.1rem 0.4rem;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
