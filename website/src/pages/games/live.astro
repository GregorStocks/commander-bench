---
import Base from '../../layouts/Base.astro';
---

<Base title="Live Game" wide>
  <link rel="stylesheet" href="/game-renderer.css" />
  <div id="live-visualizer">
    <div id="connection-status">Connecting to game server...</div>

    <div id="game-ui" class="hidden">
      <!-- Header -->
      <div id="game-header" class="game-header-bar">
        <div id="game-title">Live Game</div>
        <div id="turn-info"></div>
      </div>

      <!-- Main content: board left, log right -->
      <div id="game-content">
        <div id="game-left">
          <!-- Stack (left sidebar) -->
          <div id="stack-section" class="hidden">
            <div class="section-title">Stack</div>
            <div id="stack-cards" class="cards-row"></div>
          </div>

          <!-- Board: 2x2 player grid -->
          <div id="players-grid"></div>
        </div>

        <div id="game-right">
          <div class="game-log">
            <div class="game-log-header">
              <span class="section-title">Game Log</span>
            </div>
            <div id="log-list" class="game-log-list"></div>
          </div>
        </div>
      </div>

      <!-- Position layer for OBS positioned mode -->
      <div id="position-layer" class="position-layer hidden"></div>

      <!-- Card preview (hover) -->
      <div id="card-preview" class="hidden">
        <img id="preview-image" alt="" />
        <div class="card-meta">
          <div id="preview-name" class="card-name"></div>
          <div id="preview-type" class="card-type"></div>
          <div id="preview-stats" class="card-stats"></div>
          <pre id="preview-rules" class="card-rules"></pre>
        </div>
      </div>
    </div>
  </div>
</Base>

<style>
  #live-visualizer {
    font-family: system-ui, -apple-system, sans-serif;
  }

  #connection-status {
    text-align: center;
    padding: 4rem 0;
    color: #a0a0b8;
  }

  #connection-status.error {
    color: #e94560;
    padding: 0.5rem 1rem;
  }

  /* Header */
  #game-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    gap: 1rem;
    padding: 0.75rem 1rem;
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 8px;
    margin-bottom: 0.75rem;
  }

  #game-title {
    font-size: 1rem;
    font-weight: 600;
    color: #e94560;
  }

  #turn-info {
    font-size: 0.85rem;
    color: #a0a0b8;
    text-align: right;
  }

  /* Two-column layout */
  #game-content {
    display: flex;
    gap: 0.75rem;
    align-items: flex-start;
  }

  #game-left {
    flex: 1;
    min-width: 0;
    display: flex;
    gap: 0.75rem;
    align-items: flex-start;
  }

  #game-right {
    width: 320px;
    flex-shrink: 0;
  }

  @media (max-width: 900px) {
    #game-content {
      flex-direction: column;
    }

    #game-right {
      width: 100%;
    }
  }
</style>

<script is:inline src="/game-renderer.js"></script>
<script is:inline>
  (function () {
    var R = window.GameRenderer;
    var params = new URLSearchParams(window.location.search);
    var apiBase = params.get("api") || window.location.origin;
    var pollMs = Math.max(250, Number(params.get("pollMs") || 700));
    var usePositioned = params.get("positions") === "1";
    var useMock = params.get("mock") === "1";
    var obsMode = params.get("obs") === "1";

    // OBS mode: transparent background, hide nav/footer
    if (obsMode) {
      var nav = document.querySelector("nav");
      if (nav) nav.style.display = "none";
      var footer = document.querySelector("footer");
      if (footer) footer.style.display = "none";
      document.body.style.background = "transparent";
      var mainEl = document.querySelector("main");
      if (mainEl) { mainEl.style.padding = "0"; mainEl.style.margin = "0"; }
    }

    var statusEl = document.getElementById("connection-status");
    var gameUI = document.getElementById("game-ui");
    var turnInfoEl = document.getElementById("turn-info");
    var gameTitleEl = document.getElementById("game-title");
    var playersGrid = document.getElementById("players-grid");
    var stackSection = document.getElementById("stack-section");
    var stackCards = document.getElementById("stack-cards");
    var positionLayer = document.getElementById("position-layer");
    var visualizer = document.getElementById("live-visualizer");
    var logList = document.getElementById("log-list");

    var previewEls = {
      container: document.getElementById("card-preview"),
      image: document.getElementById("preview-image"),
      name: document.getElementById("preview-name"),
      type: document.getElementById("preview-type"),
      stats: document.getElementById("preview-stats"),
      rules: document.getElementById("preview-rules"),
    };

    var requestInFlight = false;
    var playerColorMap = {};
    var playersInitialized = false;
    var prevState = null;
    var lastEventSeq = 0;

    function initPlayerColors(players) {
      if (playersInitialized) return;
      (players || []).forEach(function (p, i) {
        playerColorMap[p.name] = i % 4;
      });
      playersInitialized = true;
    }

    function escapeHtml(str) {
      return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }

    function colorizePlayerNames(message) {
      var escaped = escapeHtml(message);
      var names = Object.keys(playerColorMap);
      names.sort(function (a, b) { return b.length - a.length; });
      names.forEach(function (name) {
        var cls = "action-" + R.PLAYER_COLORS[playerColorMap[name]];
        var escapedName = escapeHtml(name);
        escaped = escaped.split(escapedName).join('<span class="' + cls + '">' + escapedName + '</span>');
      });
      return escaped;
    }

    function appendEvent(evt) {
      if (evt.type === "player_chat") {
        var line = document.createElement("div");
        line.className = "chat-line";
        var fromIdx = playerColorMap[evt.from];
        var fromCls = fromIdx != null ? "action-" + R.PLAYER_COLORS[fromIdx] : "";
        line.innerHTML = '<span class="chat-from ' + fromCls + '">' + escapeHtml(evt.from || "") + ':</span> ' + escapeHtml(evt.message || "");
        logList.appendChild(line);
      } else {
        var line = document.createElement("div");
        line.className = "action-line";
        line.innerHTML = colorizePlayerNames(evt.message || "");
        logList.appendChild(line);
      }
    }

    function processEvents(events) {
      if (!events || events.length === 0) return;
      var newEvents = events.filter(function (e) { return e.seq > lastEventSeq; });
      if (newEvents.length === 0) return;
      newEvents.sort(function (a, b) { return a.seq - b.seq; });
      newEvents.forEach(appendEvent);
      lastEventSeq = newEvents[newEvents.length - 1].seq;
      // Auto-scroll to bottom
      logList.scrollTop = logList.scrollHeight;
    }

    async function tick() {
      if (requestInFlight) return;
      requestInFlight = true;

      try {
        var url = useMock
          ? apiBase + "/api/mock-state"
          : apiBase + "/api/state";
        var resp = await fetch(url, { cache: "no-store" });
        if (!resp.ok) throw new Error("HTTP " + resp.status);
        var raw = await resp.json();

        if (raw && raw.status === "waiting") {
          statusEl.textContent = "Waiting for game to start...";
          statusEl.classList.remove("error");
          return;
        }

        var state = R.normalizeLiveState(raw);

        // First successful state: show UI
        if (statusEl && !statusEl.classList.contains("hidden")) {
          statusEl.classList.add("hidden");
          gameUI.classList.remove("hidden");
        }

        initPlayerColors(state.players);

        // Process game events (from raw, before normalization strips them)
        processEvents(raw.events);

        // Compute diff against previous state for animations
        var diffs = prevState ? R.computeDiff(prevState, state) : null;
        prevState = state;

        // Status line
        R.renderStatusLine(turnInfoEl, state);

        // Positioned mode (OBS)
        if (usePositioned) {
          var rendered = R.renderPositionLayer(positionLayer, state, visualizer, previewEls);
          if (rendered) {
            playersGrid.classList.add("hidden");
          } else {
            playersGrid.classList.remove("hidden");
            positionLayer.classList.add("hidden");
            if (visualizer) visualizer.classList.remove("positioned-mode");
            var liveIsCommander = (state.players || []).some(function (p) { return p.commanders && p.commanders.length > 0; });
            R.renderPlayers(playersGrid, state.players, {
              cardImages: {},
              playerColorMap: playerColorMap,
              diffs: diffs,
              previewEls: previewEls,
              showTimer: true,
              priorityPlayerName: state.priority_player,
              isCommander: liveIsCommander,
            });
          }
        } else {
          var liveIsCommander2 = (state.players || []).some(function (p) { return p.commanders && p.commanders.length > 0; });
          R.renderPlayers(playersGrid, state.players, {
            cardImages: {},
            playerColorMap: playerColorMap,
            diffs: diffs,
            previewEls: previewEls,
            showTimer: true,
            priorityPlayerName: state.priority_player,
            isCommander: liveIsCommander2,
          });
        }

        // Stack
        R.renderStack(stackSection, stackCards, state.stack, {}, previewEls);

      } catch (err) {
        statusEl.textContent = "Cannot reach game server at " + apiBase + " â€” retrying...";
        statusEl.classList.add("error");
        statusEl.classList.remove("hidden");
      } finally {
        requestInFlight = false;
      }
    }

    // Preview dismiss
    window.addEventListener("blur", function () { R.hidePreview(previewEls); });
    document.addEventListener("keydown", function (e) {
      if (e.key === "Escape") R.hidePreview(previewEls);
    });

    // Rerender on resize for positioned mode
    if (usePositioned) {
      window.addEventListener("resize", function () { tick(); });
    }

    tick();
    window.setInterval(tick, pollMs);
  })();
</script>
