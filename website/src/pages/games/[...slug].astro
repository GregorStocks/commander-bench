---
import Base from '../../layouts/Base.astro';
import fs from 'node:fs';
import path from 'node:path';

export function getStaticPaths() {
  const gamesDir = path.join(process.cwd(), 'public', 'games');
  if (!fs.existsSync(gamesDir)) {
    return [];
  }
  return fs.readdirSync(gamesDir)
    .filter((f: string) => f.startsWith('game_') && f.endsWith('.json.gz'))
    .map((f: string) => ({ params: { slug: f.replace('.json.gz', '') } }));
}

const { slug } = Astro.params;
---

<Base title="Game Replay" wide>
  <link rel="stylesheet" href="/game-renderer.css" />
  <div id="visualizer">
    <div id="loading">Loading game data...</div>
    <div id="error" class="hidden"></div>

    <div id="game-ui" class="hidden">
      <!-- Header -->
      <div id="game-header">
        <div id="game-title"></div>
        <div id="youtube-link" class="hidden">
          <a id="youtube-url" href="#" target="_blank" rel="noopener">Watch on YouTube</a>
        </div>
        <div id="turn-info"></div>
      </div>

      <!-- Transport controls -->
      <div id="transport">
        <div class="transport-buttons">
          <button id="btn-start" title="First snapshot">|&lt;</button>
          <button id="btn-prev" title="Previous (Left arrow)">&lt;</button>
          <button id="btn-next" title="Next (Right arrow)">&gt;</button>
          <button id="btn-end" title="Last snapshot">&gt;|</button>
          <button id="btn-auto" title="Auto-play">Play</button>
        </div>
        <div class="turn-nav">
          <button id="btn-prev-turn" title="Previous turn ([)">&lt;T</button>
          <select id="turn-select" title="Jump to turn"></select>
          <button id="btn-next-turn" title="Next turn (])">T&gt;</button>
        </div>
        <div id="slider-container">
          <input type="range" id="slider" min="0" max="0" value="0" />
        </div>
        <input type="number" id="snapshot-jump" min="1" max="1" value="1" title="Jump to snapshot #" />
        <div id="snapshot-counter"></div>
      </div>

      <!-- Main content: board left, logs right -->
      <div id="game-content">
        <div id="game-left">
          <!-- Board: 2x2 player grid -->
          <div id="players-grid"></div>

          <!-- Stack -->
          <div id="stack-section" class="hidden">
            <div class="section-title">Stack</div>
            <div id="stack-cards" class="cards-row"></div>
          </div>
        </div>

        <div id="game-right">
          <!-- Action log -->
          <div id="action-log">
            <div class="action-log-header">
              <span class="section-title">Game Log</span>
              <div class="log-filters">
                <select id="player-filter" class="hidden" title="Filter by player">
                  <option value="">All players</option>
                </select>
                <select id="event-type-filter" class="hidden" title="Filter by event type">
                  <option value="">All events</option>
                  <option value="llm">LLM calls only</option>
                  <option value="game">Game actions only</option>
                </select>
                <label id="llm-toggle-label" class="hidden">
                  <input type="checkbox" id="llm-toggle" checked /> Show LLM thinking
                </label>
              </div>
            </div>
            <div id="action-list"></div>
          </div>
        </div>
      </div>

      <!-- Card preview (hover) -->
      <div id="card-preview" class="hidden">
        <img id="preview-image" alt="" />
        <div class="card-meta">
          <div id="preview-name" class="card-name"></div>
          <div id="preview-type" class="card-type"></div>
          <div id="preview-stats" class="card-stats"></div>
          <pre id="preview-rules" class="card-rules"></pre>
        </div>
      </div>
    </div>
  </div>
</Base>

<style>
  #visualizer {
    font-family: system-ui, -apple-system, sans-serif;
  }

  #loading, #error {
    text-align: center;
    padding: 4rem 0;
    color: #a0a0b8;
  }

  #error {
    color: #e94560;
  }

  /* Header */
  #game-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    gap: 1rem;
    padding: 0.75rem 1rem;
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 8px;
    margin-bottom: 0.75rem;
  }

  #game-title {
    font-size: 1rem;
    font-weight: 600;
    color: #e94560;
  }

  #youtube-link a {
    color: #e94560;
    text-decoration: none;
    font-size: 0.85rem;
    padding: 0.25rem 0.6rem;
    border: 1px solid #e94560;
    border-radius: 4px;
    transition: background 0.2s, color 0.2s;
  }

  #youtube-link a:hover {
    background: #e94560;
    color: #fff;
  }

  #turn-info {
    font-size: 0.85rem;
    color: #a0a0b8;
    text-align: right;
  }

  #epoch-banner {
    font-size: 0.85rem;
    color: #fbbf24;
    background: rgba(251, 191, 36, 0.08);
    border: 1px solid rgba(251, 191, 36, 0.25);
    border-radius: 6px;
    padding: 0.5rem 1rem;
    margin-bottom: 0.75rem;
  }

  #blunder-summary {
    font-size: 0.8rem;
    color: #f97316;
    font-weight: 600;
  }

  /* Transport */
  #transport {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.5rem 1rem;
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 8px;
    margin-bottom: 0.75rem;
  }

  .transport-buttons {
    display: flex;
    gap: 0.25rem;
    flex-shrink: 0;
  }

  .transport-buttons button {
    background: #0f3460;
    color: #e0e0e0;
    border: 1px solid #1a4a8a;
    border-radius: 4px;
    padding: 0.35rem 0.6rem;
    cursor: pointer;
    font-family: monospace;
    font-size: 0.85rem;
    transition: background 0.15s;
  }

  .transport-buttons button:hover {
    background: #1a4a8a;
  }

  .transport-buttons button.active {
    background: #e94560;
    border-color: #e94560;
    color: #fff;
  }

  .turn-nav {
    display: flex;
    gap: 0.25rem;
    flex-shrink: 0;
    align-items: center;
  }

  .turn-nav button {
    background: #0f3460;
    color: #e0e0e0;
    border: 1px solid #1a4a8a;
    border-radius: 4px;
    padding: 0.35rem 0.5rem;
    cursor: pointer;
    font-family: monospace;
    font-size: 0.8rem;
    transition: background 0.15s;
  }

  .turn-nav button:hover {
    background: #1a4a8a;
  }

  #turn-select {
    background: #0f3460;
    color: #e0e0e0;
    border: 1px solid #1a4a8a;
    border-radius: 4px;
    padding: 0.3rem 0.4rem;
    font-family: monospace;
    font-size: 0.8rem;
    cursor: pointer;
  }

  #slider-container {
    flex: 1;
    min-width: 100px;
    position: relative;
  }

  #slider {
    width: 100%;
    accent-color: #e94560;
  }

  #snapshot-jump {
    width: 5rem;
    background: #0f3460;
    color: #e0e0e0;
    border: 1px solid #1a4a8a;
    border-radius: 4px;
    padding: 0.3rem 0.4rem;
    font-family: monospace;
    font-size: 0.8rem;
    text-align: center;
    flex-shrink: 0;
  }

  /* Hide spin buttons on number input */
  #snapshot-jump::-webkit-inner-spin-button,
  #snapshot-jump::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  #snapshot-jump { -moz-appearance: textfield; }

  #snapshot-counter {
    font-size: 0.8rem;
    color: #a0a0b8;
    white-space: nowrap;
    min-width: 4rem;
    text-align: right;
  }

  @media (max-width: 600px) {
    #transport {
      flex-wrap: wrap;
    }

    #slider-container {
      flex-basis: 100%;
      order: 10;
    }

    #snapshot-jump {
      width: 3.5rem;
    }

    #snapshot-counter {
      min-width: auto;
    }

    #game-header {
      flex-wrap: wrap;
    }

    #turn-info {
      font-size: 0.75rem;
    }
  }

  /* Two-column layout */
  #game-content {
    display: flex;
    gap: 0.75rem;
    align-items: flex-start;
  }

  #game-left {
    flex: 1;
    min-width: 0;
  }

  #game-right {
    width: 320px;
    flex-shrink: 0;
  }

  @media (max-width: 900px) {
    #game-content {
      flex-direction: column;
    }

    #game-right {
      width: 100%;
    }
  }

  /* Action log */
  #action-log {
    padding: 0.75rem 1rem;
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 8px;
    margin-bottom: 0.75rem;
    position: sticky;
    top: 0.5rem;
  }

  .action-log-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.4rem;
    flex-wrap: wrap;
    gap: 0.3rem;
  }

  .log-filters {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    flex-wrap: wrap;
  }

  #player-filter, #event-type-filter {
    background: #0f3460;
    color: #e0e0e0;
    border: 1px solid #1a4a8a;
    border-radius: 4px;
    padding: 0.2rem 0.3rem;
    font-size: 0.72rem;
    cursor: pointer;
  }

  #llm-toggle-label {
    font-size: 0.72rem;
    color: #888;
    cursor: pointer;
    user-select: none;
  }

  #llm-toggle {
    margin-right: 4px;
    accent-color: #e94560;
  }

  #action-list {
    max-height: calc(100vh - 8rem);
    overflow-y: auto;
    font-size: 0.8rem;
    line-height: 1.5;
  }

</style>

<script is:inline src="/game-renderer.js"></script>
<script is:inline>
  (function () {
    var R = window.GameRenderer;

    var slug = window.location.pathname.replace(/^\/games\//, "").replace(/\/$/, "");
    if (!slug) {
      showError("No game ID in URL.");
      return;
    }

    var loadingEl = document.getElementById("loading");
    var errorEl = document.getElementById("error");
    var gameUI = document.getElementById("game-ui");

    // Transport
    var btnStart = document.getElementById("btn-start");
    var btnPrev = document.getElementById("btn-prev");
    var btnNext = document.getElementById("btn-next");
    var btnEnd = document.getElementById("btn-end");
    var btnAuto = document.getElementById("btn-auto");
    var slider = document.getElementById("slider");
    var counterEl = document.getElementById("snapshot-counter");
    var snapshotJump = document.getElementById("snapshot-jump");

    // Display
    var gameTitleEl = document.getElementById("game-title");
    var turnInfoEl = document.getElementById("turn-info");
    var playersGrid = document.getElementById("players-grid");
    var stackSection = document.getElementById("stack-section");
    var stackCards = document.getElementById("stack-cards");
    var actionList = document.getElementById("action-list");

    // Turn navigation
    var turnSelect = document.getElementById("turn-select");
    var btnPrevTurn = document.getElementById("btn-prev-turn");
    var btnNextTurn = document.getElementById("btn-next-turn");

    // Card preview elements
    var previewEls = {
      container: document.getElementById("card-preview"),
      image: document.getElementById("preview-image"),
      name: document.getElementById("preview-name"),
      type: document.getElementById("preview-type"),
      stats: document.getElementById("preview-stats"),
      rules: document.getElementById("preview-rules"),
    };

    var game = null;
    var currentIndex = 0;
    var autoPlayInterval = null;
    var playerColorMap = {};
    var playerMeta = {};
    var eloData = null;
    var turnStartIndices = [];
    var showLlm = true;
    var traceByTs = {};  // ts -> trace event lookup for LLM I/O display
    var filterPlayer = "";  // "" = all players
    var filterEventType = "";  // "" = all, "llm" = LLM only, "game" = game actions only

    // LLM toggle
    var llmToggleLabel = document.getElementById("llm-toggle-label");
    var llmToggle = document.getElementById("llm-toggle");
    llmToggle.addEventListener("change", function () {
      showLlm = llmToggle.checked;
      renderSnapshot(currentIndex);
    });

    // Player filter
    var playerFilter = document.getElementById("player-filter");
    playerFilter.addEventListener("change", function () {
      filterPlayer = playerFilter.value;
      renderSnapshot(currentIndex);
    });

    // Event type filter
    var eventTypeFilter = document.getElementById("event-type-filter");
    eventTypeFilter.addEventListener("change", function () {
      filterEventType = eventTypeFilter.value;
      renderSnapshot(currentIndex);
    });

    function showError(msg) {
      loadingEl.classList.add("hidden");
      errorEl.textContent = msg;
      errorEl.classList.remove("hidden");
    }

    function escapeHtml(str) {
      return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }

    function colorizePlayerNames(message) {
      var escaped = escapeHtml(message);
      var names = Object.keys(playerColorMap);
      names.sort(function (a, b) { return b.length - a.length; });
      names.forEach(function (name) {
        var cls = "action-" + R.PLAYER_COLORS[playerColorMap[name]];
        var escapedName = escapeHtml(name);
        escaped = escaped.split(escapedName).join('<span class="' + cls + '">' + escapedName + '</span>');
      });
      return escaped;
    }

    function playerColorClass(playerName) {
      var idx = playerColorMap[playerName];
      return idx != null ? "llm-player-" + idx : "";
    }

    function playerSpan(playerName) {
      var idx = playerColorMap[playerName];
      var cls = idx != null ? "action-" + R.PLAYER_COLORS[idx] : "";
      return '<span class="llm-player ' + cls + '">' + escapeHtml(playerName) + '</span>';
    }

    function formatToolArgs(args) {
      if (!args || typeof args !== "object") return "";
      var keys = Object.keys(args);
      if (keys.length === 0) return "";
      var parts = [];
      keys.forEach(function (k) {
        var v = args[k];
        if (typeof v === "string" && v.length > 40) v = v.substring(0, 40) + "...";
        else if (typeof v === "object") v = JSON.stringify(v).substring(0, 40) + (JSON.stringify(v).length > 40 ? "..." : "");
        parts.push(k + "=" + v);
      });
      return parts.join(", ");
    }

    function tryFormatJson(str) {
      if (!str || typeof str !== "string") return str || "";
      try {
        return JSON.stringify(JSON.parse(str), null, 2);
      } catch (e) {
        return str;
      }
    }

    function renderLlmEvent(event) {
      var type = event.type;

      if (type === "llm_response") {
        var hasReasoning = event.reasoning && event.reasoning.trim();
        var hasThinking = event.thinking && event.thinking.trim();
        var hasToolCalls = event.toolCalls && event.toolCalls.length > 0;

        if (hasReasoning || hasThinking) {
          // Full thought block with reasoning and/or extended thinking
          var div = document.createElement("div");
          div.className = "llm-event llm-thought " + playerColorClass(event.player);

          var header = '<span class="thinking-badge">thinking</span>' + playerSpan(event.player);
          if (event.costUsd != null) {
            header += '<span class="llm-cost">$' + event.costUsd.toFixed(4) + '</span>';
          }
          var headerEl = document.createElement("div");
          headerEl.innerHTML = header;
          div.appendChild(headerEl);

          // Extended thinking (chain-of-thought) in a collapsible block
          if (hasThinking) {
            var thinkDetails = document.createElement("details");
            thinkDetails.className = "llm-thinking-block";
            var thinkSummary = document.createElement("summary");
            thinkSummary.textContent = "Thinking (" + event.thinking.length + " chars)";
            thinkDetails.appendChild(thinkSummary);
            var thinkPre = document.createElement("pre");
            thinkPre.className = "llm-thinking-text";
            thinkPre.textContent = event.thinking;
            thinkDetails.appendChild(thinkPre);
            div.appendChild(thinkDetails);
          }

          if (hasReasoning) {
            var reasoningEl = document.createElement("div");
            reasoningEl.className = "llm-reasoning";
            reasoningEl.textContent = event.reasoning;
            div.appendChild(reasoningEl);
          }

          // Full LLM I/O trace (expandable)
          var trace = traceByTs[event.ts + "|" + event.player];
          if (trace) {
            var traceDetails = document.createElement("details");
            traceDetails.className = "llm-trace-block";
            var traceSummary = document.createElement("summary");
            var promptTok = (event.usage && event.usage.promptTokens) || "?";
            var compTok = (event.usage && event.usage.completionTokens) || "?";
            traceSummary.textContent = "Full LLM I/O (" + promptTok + "\u2192" + compTok + " tokens)";
            traceDetails.appendChild(traceSummary);
            var tracePre = document.createElement("pre");
            tracePre.className = "llm-trace-text";
            tracePre.textContent = JSON.stringify({request: trace.request, response: trace.response}, null, 2);
            traceDetails.appendChild(tracePre);
            div.appendChild(traceDetails);
          }

          if (hasToolCalls) {
            var tcEl = document.createElement("div");
            tcEl.className = "llm-tool-calls";
            tcEl.textContent = event.toolCalls.map(function (tc) {
              return tc.name + "(" + formatToolArgs(typeof tc.arguments === "string" ? (function () { try { return JSON.parse(tc.arguments); } catch (e) { return {}; } })() : tc.arguments) + ")";
            }).join(", ");
            div.appendChild(tcEl);
          }

          return div;
        } else if (hasToolCalls) {
          // Compact tool-call-only line (no reasoning text)
          var div = document.createElement("div");
          div.className = "llm-event llm-compact";
          var toolNames = event.toolCalls.map(function (tc) { return tc.name; }).join(", ");
          div.innerHTML = playerSpan(event.player) + " " + escapeHtml(toolNames);
          if (event.costUsd != null) {
            div.innerHTML += '<span class="llm-cost">$' + event.costUsd.toFixed(4) + '</span>';
          }

          // Full LLM I/O trace for compact events too
          var trace = traceByTs[event.ts + "|" + event.player];
          if (trace) {
            var traceDetails = document.createElement("details");
            traceDetails.className = "llm-trace-block";
            var traceSummary = document.createElement("summary");
            var promptTok = (event.usage && event.usage.promptTokens) || "?";
            var compTok = (event.usage && event.usage.completionTokens) || "?";
            traceSummary.textContent = "Full LLM I/O (" + promptTok + "\u2192" + compTok + " tokens)";
            traceDetails.appendChild(traceSummary);
            var tracePre = document.createElement("pre");
            tracePre.className = "llm-trace-text";
            tracePre.textContent = JSON.stringify({request: trace.request, response: trace.response}, null, 2);
            traceDetails.appendChild(tracePre);
            div.appendChild(traceDetails);
          }

          return div;
        }
        return null; // Empty response, skip
      }

      if (type === "tool_call") {
        var details = document.createElement("details");
        details.className = "llm-event llm-tool-result";

        var summary = document.createElement("summary");
        var argsSummary = formatToolArgs(event.args);
        var latency = event.latencyMs != null ? " " + (event.latencyMs / 1000).toFixed(1) + "s" : "";
        summary.innerHTML = playerSpan(event.player) + " " +
          escapeHtml(event.tool) + "(" + escapeHtml(argsSummary) + ")" +
          (latency ? '<span class="llm-cost">' + latency + '</span>' : "");
        details.appendChild(summary);

        if (event.result) {
          var pre = document.createElement("pre");
          pre.textContent = tryFormatJson(event.result);
          details.appendChild(pre);
        }

        return details;
      }

      // Meta events: stall, llm_error, context_trim, context_reset, auto_pilot_mode
      var div = document.createElement("div");
      div.className = "llm-event llm-meta";

      if (type === "stall") {
        div.textContent = event.player + " stalled (" + (event.turnsWithoutProgress || 0) + " turns without progress)";
      } else if (type === "llm_error") {
        div.textContent = event.player + " error: " + (event.errorType || "") + " " + (event.errorMessage || "");
      } else if (type === "context_trim") {
        div.textContent = event.player + " context trimmed: " + (event.messagesBefore || 0) + " -> " + (event.messagesAfter || 0) + " messages";
      } else if (type === "context_reset") {
        div.textContent = event.player + " context reset: " + (event.reason || "");
      } else if (type === "auto_pilot_mode") {
        div.textContent = event.player + " switched to auto-pilot: " + (event.reason || "");
      } else {
        div.textContent = event.player + " " + type;
      }

      return div;
    }

    function renderAnnotation(ann) {
      var div = document.createElement("div");
      div.className = "annotation-block severity-" + ann.severity;

      var header = document.createElement("div");
      header.className = "annotation-header";
      var badge = document.createElement("span");
      badge.className = "annotation-badge severity-" + ann.severity;
      badge.textContent = ann.severity + " blunder";
      header.appendChild(badge);
      var catEl = document.createElement("span");
      catEl.className = "annotation-category";
      catEl.textContent = ann.category.replace(/_/g, " ");
      header.appendChild(catEl);
      div.appendChild(header);

      var desc = document.createElement("div");
      desc.className = "annotation-description";
      desc.textContent = ann.description;
      div.appendChild(desc);

      var details = document.createElement("details");
      details.className = "annotation-details";
      var summary = document.createElement("summary");
      summary.textContent = "Analysis";
      details.appendChild(summary);
      var content = document.createElement("div");
      content.innerHTML =
        '<div class="annotation-field"><strong>Action taken:</strong> ' + escapeHtml(ann.actionTaken) + '</div>' +
        '<div class="annotation-field"><strong>Better line:</strong> ' + escapeHtml(ann.betterLine) + '</div>' +
        '<div class="annotation-field"><strong>Why the LLM erred:</strong> ' + escapeHtml(ann.llmReasoning) + '</div>';
      details.appendChild(content);
      div.appendChild(details);

      return div;
    }

    function renderAnnotationMarkers(annotations, totalSnapshots) {
      var container = document.getElementById("slider-container");
      var existing = container.querySelector(".annotation-markers");
      if (existing) existing.remove();

      if (!annotations || annotations.length === 0) return;

      var markers = document.createElement("div");
      markers.className = "annotation-markers";
      annotations.forEach(function (ann) {
        var dot = document.createElement("div");
        dot.className = "annotation-marker severity-" + ann.severity;
        var pct = totalSnapshots > 1 ? (ann.snapshotIndex / (totalSnapshots - 1)) * 100 : 50;
        dot.style.left = pct + "%";
        dot.title = ann.player + " (" + ann.severity + "): " + ann.description.substring(0, 80);
        dot.addEventListener("click", function () { goTo(ann.snapshotIndex); });
        markers.appendChild(dot);
      });
      container.appendChild(markers);
    }

    function renderSnapshot(index) {
      var snap = game.snapshots[index];
      if (!snap) return;

      // Compute diff against previous snapshot
      var prevSnap = index > 0 ? game.snapshots[index - 1] : null;
      var diffs = R.computeDiff(prevSnap, snap);

      // Turn info
      var phase = snap.phase || "";
      var step = snap.step || "";
      var phaseDisplay = step && step !== phase ? phase + " / " + step : phase;
      turnInfoEl.textContent =
        "Turn " + snap.turn + "/" + game.totalTurns +
        " | " + phaseDisplay +
        " | Active: " + (snap.active_player || "?");

      // Players
      R.renderPlayers(playersGrid, snap.players, {
        cardImages: game.cardImages,
        playerColorMap: playerColorMap,
        playerMeta: playerMeta,
        diffs: diffs,
        previewEls: previewEls,
        priorityPlayerName: snap.priority_player,
      });

      // Stack
      R.renderStack(stackSection, stackCards, snap.stack, game.cardImages, previewEls);

      // Action log: show all actions up to current snapshot (persistent/accumulated)
      actionList.innerHTML = "";
      var prevSeq = index > 0 ? game.snapshots[index - 1].seq : 0;
      var curSeq = snap.seq;

      // When filtering by player, show ALL LLM events (not just current step window)
      // so you can see the full call log for that player
      var showAllLlm = filterPlayer || filterEventType === "llm";

      // All game actions + chat up to current snapshot
      var allActions = game.actions.filter(function (a) {
        if (a.seq > curSeq) return false;
        if (filterPlayer) {
          if (a.type === "chat") {
            if (a.from !== filterPlayer) return false;
          } else {
            if (a.message.indexOf(filterPlayer) === -1) return false;
          }
        }
        return true;
      });

      // LLM events
      var hasLlmEvents = game.llmEvents && game.llmEvents.length > 0;
      var relevantLlm = [];
      if (hasLlmEvents && showLlm) {
        if (showAllLlm) {
          // Show all LLM events up to current snapshot timestamp
          var curTs = snap.ts || "";
          relevantLlm = game.llmEvents.filter(function (e) {
            if (curTs && e.ts > curTs) return false;
            if (filterPlayer && e.player !== filterPlayer) return false;
            return true;
          });
        } else {
          // Default: windowed to current step
          var prevTs = prevSnap ? (prevSnap.ts || "") : "";
          var curTs = snap.ts || "";
          if (curTs) {
            relevantLlm = game.llmEvents.filter(function (e) {
              return e.ts > prevTs && e.ts <= curTs;
            });
          }
        }
      }

      // Render accumulated game actions and chat (unless filtering to LLM only)
      if (filterEventType !== "llm") {
        allActions.forEach(function (a) {
          if (a.type === "chat") {
            var line = document.createElement("div");
            line.className = "chat-line";
            var fromIdx = playerColorMap[a.from];
            var fromCls = fromIdx != null ? "action-" + R.PLAYER_COLORS[fromIdx] : "";
            line.innerHTML = '<span class="chat-badge">chat</span><span class="chat-from ' + fromCls + '">' + escapeHtml(a.from || "") + ':</span> ' + escapeHtml(a.message);
            actionList.appendChild(line);
          } else {
            var line = document.createElement("div");
            line.className = "action-line";
            // Highlight actions from the current step
            if (a.seq > prevSeq) {
              line.style.color = "#e0e0f0";
            }
            line.innerHTML = colorizePlayerNames(a.message);
            actionList.appendChild(line);
          }
        });
      }

      // Append LLM events (unless filtering to game actions only)
      if (filterEventType !== "game" && relevantLlm.length > 0) {
        relevantLlm.forEach(function (e) {
          var el = renderLlmEvent(e);
          if (el) actionList.appendChild(el);
        });
      }

      // Render annotations for this snapshot
      if (game.annotations) {
        game.annotations.forEach(function (ann) {
          if (ann.snapshotIndex === index) {
            actionList.appendChild(renderAnnotation(ann));
          }
        });
      }

      // Auto-scroll to bottom
      actionList.scrollTop = actionList.scrollHeight;

      // Update transport
      slider.value = String(index);
      snapshotJump.value = String(index + 1);
      counterEl.textContent = (index + 1) + " / " + game.snapshots.length;

      // Sync turn dropdown
      if (turnStartIndices.length > 0) {
        var currentTurn = snap.turn;
        for (var ti = turnStartIndices.length - 1; ti >= 0; ti--) {
          if (turnStartIndices[ti].turn <= currentTurn) {
            turnSelect.selectedIndex = ti;
            break;
          }
        }
      }

    }

    function goTo(index) {
      currentIndex = Math.max(0, Math.min(index, game.snapshots.length - 1));
      renderSnapshot(currentIndex);
    }

    function toggleAutoPlay() {
      if (autoPlayInterval) {
        clearInterval(autoPlayInterval);
        autoPlayInterval = null;
        btnAuto.textContent = "Play";
        btnAuto.classList.remove("active");
      } else {
        btnAuto.textContent = "Pause";
        btnAuto.classList.add("active");
        autoPlayInterval = setInterval(function () {
          if (currentIndex >= game.snapshots.length - 1) {
            toggleAutoPlay();
            return;
          }
          goTo(currentIndex + 1);
        }, 500);
      }
    }

    function fetchGzJson(url) {
      return fetch(url).then(function (r) {
        if (!r.ok) throw new Error("Game not found (HTTP " + r.status + ")");
        var ds = new DecompressionStream("gzip");
        var decompressed = r.body.pipeThrough(ds);
        return new Response(decompressed).json();
      });
    }

    // Load game data + Elo data in parallel
    Promise.all([
      fetchGzJson("/games/" + slug + ".json.gz"),
      fetch("/data/elo.json").then(function (r) {
        return r.ok ? r.json() : {};
      }).catch(function () { return {}; }),
    ])
      .then(function (results) {
        var data = results[0];
        eloData = results[1];
        game = data;

        if (!game.snapshots || game.snapshots.length === 0) {
          showError("No snapshots in game data.");
          return;
        }

        // Show UI
        loadingEl.classList.add("hidden");
        gameUI.classList.remove("hidden");

        // Build player color map and meta
        var gameElo = eloData[game.id] || {};
        (game.players || []).forEach(function (p, i) {
          playerColorMap[p.name] = i % 4;
          if (p.model || p.totalCostUsd != null) {
            var meta = { model: p.model, totalCostUsd: p.totalCostUsd };
            var eloKey = p.model && p.reasoningEffort ? p.model + "::" + p.reasoningEffort : p.model;
            var elo = eloKey ? gameElo[eloKey] : null;
            if (elo) {
              meta.eloBefore = elo.before;
              meta.eloAfter = elo.after;
            }
            playerMeta[p.name] = meta;
          }
        });

        // Show LLM toggle and filters if we have LLM events
        if (game.llmEvents && game.llmEvents.length > 0) {
          llmToggleLabel.classList.remove("hidden");
          eventTypeFilter.classList.remove("hidden");
        }

        // Populate player filter dropdown
        if (game.players && game.players.length > 1) {
          game.players.forEach(function (p) {
            var opt = document.createElement("option");
            opt.value = p.name;
            opt.textContent = p.name;
            playerFilter.appendChild(opt);
          });
          playerFilter.classList.remove("hidden");
        }

        // Build trace lookup by timestamp
        if (game.llmTrace) {
          game.llmTrace.forEach(function (t) {
            traceByTs[t.ts + "|" + t.player] = t;
          });
        }

        // Build turn start indices
        var lastTurn = -1;
        game.snapshots.forEach(function (snap, i) {
          if (snap.turn !== lastTurn) {
            turnStartIndices.push({ turn: snap.turn, index: i });
            lastTurn = snap.turn;
          }
        });

        // Populate turn dropdown
        turnStartIndices.forEach(function (t) {
          var opt = document.createElement("option");
          opt.value = String(t.index);
          opt.textContent = "Turn " + t.turn;
          turnSelect.appendChild(opt);
        });

        // Title
        var playerNames = (game.players || []).map(function (p) {
          return p.deckName || p.commander || p.name;
        }).join(" vs ");
        gameTitleEl.textContent = playerNames;

        // YouTube link
        if (game.youtubeUrl) {
          var ytLink = document.getElementById("youtube-link");
          var ytUrl = document.getElementById("youtube-url");
          ytUrl.href = game.youtubeUrl;
          ytLink.classList.remove("hidden");
        }

        // Blunder summary in header
        if (game.annotations && game.annotations.length > 0) {
          var counts = { minor: 0, moderate: 0, major: 0 };
          game.annotations.forEach(function (a) { counts[a.severity] = (counts[a.severity] || 0) + 1; });
          var summaryEl = document.createElement("div");
          summaryEl.id = "blunder-summary";
          var parts = [];
          if (counts.major > 0) parts.push(counts.major + " major");
          if (counts.moderate > 0) parts.push(counts.moderate + " moderate");
          if (counts.minor > 0) parts.push(counts.minor + " minor");
          summaryEl.textContent = parts.join(", ") + " blunder" + (game.annotations.length !== 1 ? "s" : "");
          document.getElementById("game-header").appendChild(summaryEl);

          // Render timeline markers
          renderAnnotationMarkers(game.annotations, game.snapshots.length);
        }

        // Old harness epoch banner
        var epochBoundaries = [["20260212_224200", 2], ["20260214_084000", 3]];
        var minEpoch = 2;
        var gameEpoch = game.harnessEpoch;
        if (gameEpoch == null) {
          var gameTs = game.id.replace("game_", "");
          gameEpoch = 1;
          for (var eb = 0; eb < epochBoundaries.length; eb++) {
            if (gameTs >= epochBoundaries[eb][0]) gameEpoch = epochBoundaries[eb][1];
          }
        }
        if (gameEpoch < minEpoch) {
          var epochBanner = document.createElement("div");
          epochBanner.id = "epoch-banner";
          epochBanner.textContent =
            "This game was played on an older harness version (epoch " + gameEpoch +
            "). Its results are not included in leaderboard ratings.";
          document.getElementById("game-header").after(epochBanner);
        }

        // Set up transport
        slider.max = String(game.snapshots.length - 1);
        snapshotJump.max = String(game.snapshots.length);

        snapshotJump.addEventListener("change", function () {
          var val = Number(snapshotJump.value);
          if (val >= 1 && val <= game.snapshots.length) {
            goTo(val - 1);
          }
        });
        snapshotJump.addEventListener("keydown", function (e) {
          if (e.key === "Enter") {
            e.preventDefault();
            snapshotJump.blur();
            var val = Number(snapshotJump.value);
            if (val >= 1 && val <= game.snapshots.length) {
              goTo(val - 1);
            }
          }
        });

        btnStart.addEventListener("click", function () { goTo(0); });
        btnPrev.addEventListener("click", function () { goTo(currentIndex - 1); });
        btnNext.addEventListener("click", function () { goTo(currentIndex + 1); });
        btnEnd.addEventListener("click", function () { goTo(game.snapshots.length - 1); });
        btnAuto.addEventListener("click", toggleAutoPlay);
        slider.addEventListener("input", function () { goTo(Number(slider.value)); });

        // Turn navigation
        turnSelect.addEventListener("change", function () { goTo(Number(turnSelect.value)); });
        btnPrevTurn.addEventListener("click", function () {
          var idx = Math.max(0, turnSelect.selectedIndex - 1);
          turnSelect.selectedIndex = idx;
          goTo(Number(turnSelect.value));
        });
        btnNextTurn.addEventListener("click", function () {
          var idx = Math.min(turnStartIndices.length - 1, turnSelect.selectedIndex + 1);
          turnSelect.selectedIndex = idx;
          goTo(Number(turnSelect.value));
        });

        document.addEventListener("keydown", function (e) {
          if (e.key === "ArrowRight") { e.preventDefault(); goTo(currentIndex + 1); }
          if (e.key === "ArrowLeft") { e.preventDefault(); goTo(currentIndex - 1); }
          if (e.key === "Home") { e.preventDefault(); goTo(0); }
          if (e.key === "End") { e.preventDefault(); goTo(game.snapshots.length - 1); }
          if (e.key === " ") { e.preventDefault(); toggleAutoPlay(); }
          if (e.key === "Escape") { R.hidePreview(previewEls); }
          if (e.key === "[") { e.preventDefault(); btnPrevTurn.click(); }
          if (e.key === "]") { e.preventDefault(); btnNextTurn.click(); }
        });

        // Render first snapshot
        renderSnapshot(0);
      })
      .catch(function (err) {
        showError(err.message || "Failed to load game data.");
      });

    window.addEventListener("blur", function () { R.hidePreview(previewEls); });
  })();
</script>
