---
import Base from '../layouts/Base.astro';
import benchmarkData from '../data/benchmark-results.json';

const models = benchmarkData.models;
const providers = [...new Set(models.map((m: any) => m.provider))].sort();
const hasData = models.length > 0;
---

<Base title="Leaderboard">
  <h1>Leaderboard</h1>

  {hasData ? (
    <p class="subtitle">
      Model ratings based on {benchmarkData.totalGames.toLocaleString()} Commander games.
      Last updated: <time>{new Date(benchmarkData.generatedAt).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' })}</time>.
    </p>

    <details class="rating-info">
      <summary>How ratings work</summary>
      <div class="rating-info-body">
        <p>
          Ratings use the <a href="https://openskill.me/" target="_blank" rel="noopener">OpenSkill</a>
          PlackettLuce model, a Bayesian rating system designed for multiplayer games.
          Unlike Elo (which only handles 1v1), PlackettLuce uses the full finishing
          order (1st through 4th) to update ratings after each Commander game.
        </p>
        <p>
          Each model starts at <strong>1600</strong>. The displayed rating is a
          conservative estimate: <code>&mu; &minus; 3&sigma;</code>, scaled to a
          familiar range. As a model plays more games, its uncertainty (&sigma;)
          decreases, and the rating converges toward the model's true skill (&mu;).
        </p>
      </div>
    </details>

    <div class="filters">
      <input
        type="text"
        id="search-input"
        placeholder="Search model name..."
        autocomplete="off"
      />
      <select id="provider-filter">
        <option value="">All Providers</option>
        {providers.map((p: string) => (
          <option value={p}>{p}</option>
        ))}
      </select>
    </div>

    <div class="table-wrap">
      <table id="leaderboard-table">
        <thead>
          <tr>
            <th data-sort="modelName" data-type="string">Model Name</th>
            <th data-sort="provider" data-type="string">Provider</th>
            <th data-sort="rating" data-type="number" class="sorted desc">Rating <span class="sort-arrow">&#9660;</span></th>
            <th data-sort="gamesPlayed" data-type="number">Games Played</th>
            <th data-sort="winRate" data-type="number">Win Rate</th>
            <th data-sort="avgApiCost" data-type="number">Avg API Cost</th>
          </tr>
        </thead>
        <tbody>
          {models.map((m: any) => (
            <tr
              data-model-name={m.modelName.toLowerCase()}
              data-provider={m.provider}
              data-rating={m.rating}
              data-games-played={m.gamesPlayed}
              data-win-rate={m.winRate}
              data-avg-api-cost={m.avgApiCost}
            >
              <td class="model-name">{m.modelName}</td>
              <td>{m.provider}</td>
              <td class="num">{m.rating}</td>
              <td class="num">{m.gamesPlayed}</td>
              <td class="num">{(m.winRate * 100).toFixed(1)}%</td>
              <td class="num">${m.avgApiCost.toFixed(2)}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>

    <p class="no-results" id="no-results" style="display: none;">
      No models match your filters.
    </p>
  ) : (
    <p class="empty-state">No games have been played yet. Check back soon!</p>
  )}
</Base>

<script>
  const table = document.getElementById('leaderboard-table') as HTMLTableElement | null;
  if (!table) {
    // No data yet, nothing to make interactive
  } else {
  const tbody = table.querySelector('tbody')!;
  const headers = table.querySelectorAll('th[data-sort]');
  const searchInput = document.getElementById('search-input') as HTMLInputElement;
  const providerFilter = document.getElementById('provider-filter') as HTMLSelectElement;
  const noResults = document.getElementById('no-results')!;

  function sortTable(column: string, type: string, ascending: boolean) {
    const rows = Array.from(tbody.querySelectorAll('tr'));

    rows.sort((a, b) => {
      const elA = a as HTMLElement;
      const elB = b as HTMLElement;
      let valA: string | number;
      let valB: string | number;

      if (type === 'number') {
        valA = parseFloat(elA.dataset[column] ?? '0');
        valB = parseFloat(elB.dataset[column] ?? '0');
      } else {
        valA = (elA.dataset[column] ?? '').toLowerCase();
        valB = (elB.dataset[column] ?? '').toLowerCase();
      }

      if (valA < valB) return ascending ? -1 : 1;
      if (valA > valB) return ascending ? 1 : -1;
      return 0;
    });

    rows.forEach(row => tbody.appendChild(row));
  }

  headers.forEach(th => {
    th.addEventListener('click', () => {
      const el = th as HTMLElement;
      const column = el.dataset.sort!;
      const type = el.dataset.type!;

      const wasSorted = th.classList.contains('sorted');
      const wasAsc = th.classList.contains('asc');
      const ascending = wasSorted ? !wasAsc : (type === 'string');

      headers.forEach(h => {
        h.classList.remove('sorted', 'asc', 'desc');
        const arrow = h.querySelector('.sort-arrow');
        if (arrow) arrow.textContent = '';
      });

      th.classList.add('sorted', ascending ? 'asc' : 'desc');
      let arrow = th.querySelector('.sort-arrow');
      if (!arrow) {
        arrow = document.createElement('span');
        arrow.className = 'sort-arrow';
        th.appendChild(arrow);
      }
      arrow.textContent = ascending ? '\u25B2' : '\u25BC';

      sortTable(column, type, ascending);
    });
  });

  function applyFilters() {
    const searchTerm = searchInput.value.toLowerCase().trim();
    const provider = providerFilter.value;
    const rows = tbody.querySelectorAll('tr');
    let visibleCount = 0;

    rows.forEach(row => {
      const el = row as HTMLElement;
      const matchesSearch = !searchTerm || (el.dataset.modelName ?? '').includes(searchTerm);
      const matchesProvider = !provider || el.dataset.provider === provider;
      const visible = matchesSearch && matchesProvider;

      el.style.display = visible ? '' : 'none';
      if (visible) visibleCount++;
    });

    noResults.style.display = visibleCount === 0 ? '' : 'none';
  }

  searchInput.addEventListener('input', applyFilters);
  providerFilter.addEventListener('change', applyFilters);
  }
</script>

<style>
  h1 {
    color: #e94560;
    margin-bottom: 0.5rem;
  }

  .subtitle {
    color: #a0a0b8;
    font-size: 0.95rem;
    margin-bottom: 1.5rem;
    line-height: 1.7;
  }

  .subtitle time {
    color: #e0e0e0;
  }

  .rating-info {
    margin-bottom: 1.5rem;
    border: 1px solid #0f3460;
    border-radius: 4px;
    font-size: 0.9rem;
  }

  .rating-info summary {
    padding: 0.5rem 0.75rem;
    cursor: pointer;
    color: #a0a0b8;
    user-select: none;
  }

  .rating-info summary:hover {
    color: #e0e0e0;
  }

  .rating-info-body {
    padding: 0 0.75rem 0.75rem;
    color: #a0a0b8;
    line-height: 1.6;
  }

  .rating-info-body p {
    margin: 0.5rem 0;
  }

  .rating-info-body a {
    color: #e94560;
  }

  .rating-info-body code {
    background: #16213e;
    padding: 0.1rem 0.35rem;
    border-radius: 3px;
    font-size: 0.85em;
  }

  .filters {
    display: flex;
    gap: 1rem;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
  }

  .filters input,
  .filters select {
    font-family: inherit;
    font-size: 0.9rem;
    padding: 0.5rem 0.75rem;
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 4px;
    color: #e0e0e0;
    outline: none;
    transition: border-color 0.2s;
  }

  .filters input {
    flex: 1;
    min-width: 200px;
  }

  .filters select {
    min-width: 160px;
  }

  .filters input:focus,
  .filters select:focus {
    border-color: #e94560;
  }

  .filters input::placeholder {
    color: #a0a0b8;
  }

  .table-wrap {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
  }

  th {
    text-align: left;
    padding: 0.6rem 0.75rem;
    border-bottom: 2px solid #0f3460;
    color: #a0a0b8;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
    white-space: nowrap;
    transition: color 0.2s;
  }

  th:hover {
    color: #e94560;
  }

  th.sorted {
    color: #e94560;
  }

  .sort-arrow {
    display: inline-block;
    margin-left: 0.35rem;
    font-size: 0.7rem;
    vertical-align: middle;
  }

  td {
    padding: 0.6rem 0.75rem;
    border-bottom: 1px solid rgba(15, 52, 96, 0.5);
  }

  .model-name {
    font-weight: 600;
    color: #e0e0e0;
  }

  .num {
    font-variant-numeric: tabular-nums;
    text-align: right;
  }

  th[data-sort="rating"],
  th[data-sort="gamesPlayed"],
  th[data-sort="winRate"],
  th[data-sort="avgApiCost"] {
    text-align: right;
  }

  tbody tr {
    transition: background 0.15s;
  }

  tbody tr:nth-child(even) {
    background: rgba(22, 33, 62, 0.3);
  }

  tbody tr:hover {
    background: rgba(233, 69, 96, 0.08);
  }

  .no-results {
    color: #a0a0b8;
    font-style: italic;
    text-align: center;
    padding: 2rem 0;
  }

  .empty-state {
    color: #a0a0b8;
    text-align: center;
    padding: 4rem 0;
    font-size: 1.1rem;
  }

  @media (max-width: 600px) {
    .filters {
      flex-direction: column;
    }

    .filters input,
    .filters select {
      width: 100%;
    }

    th, td {
      padding: 0.5rem;
      font-size: 0.8rem;
    }
  }
</style>
